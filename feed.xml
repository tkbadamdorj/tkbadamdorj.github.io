<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://tkbadamdorj.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://tkbadamdorj.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-03T02:04:19+00:00</updated><id>https://tkbadamdorj.github.io/feed.xml</id><title type="html">Taivanbat Badamdorj (TK)</title><subtitle></subtitle><entry><title type="html">I cut our CI test load by 60% on top of pants’ built-in optimizations</title><link href="https://tkbadamdorj.github.io/blog/2025/pants/" rel="alternate" type="text/html" title="I cut our CI test load by 60% on top of pants’ built-in optimizations"/><published>2025-02-02T15:09:00+00:00</published><updated>2025-02-02T15:09:00+00:00</updated><id>https://tkbadamdorj.github.io/blog/2025/pants</id><content type="html" xml:base="https://tkbadamdorj.github.io/blog/2025/pants/"><![CDATA[<h1 id="tldr">TL;DR:</h1> <ul> <li>As codebases grow, so do the number of tests and the duration of your CI pipeline</li> <li>However, not every test needs to run for every small change</li> <li><a href="https://www.pantsbuild.org/">pants</a> is a build system that thrives at automatic dependency inference</li> <li>Because it infers dependencies, you can use it to only run the set of affected unit tests</li> <li>On top of pants’ built-in optimizations, I cut our CI test load by another 60% using pants’ dependency introspection tools</li> </ul> <h4 id="how-do-tests-get-in-the-way-of-moving-fast">How do tests get in the way of moving fast?</h4> <p>You decide as a team that tests are important. You don’t want broken code. So you make it a habit to add unit tests whenever you add new code. Small pull requests are also important, as they get faster and better reviews, improve code quality, and are less likely to break things (take a look at this <a href="https://www.swarmia.com/blog/why-small-pull-requests-are-better/">article</a>). Over time you develop a codebase that is robust and beautiful. But merging also takes longer because the suite of tests that need to be run before you can merge your code is much bigger! This can be frustrating as in many cases, you <em>know</em> what you wrote doesn’t affect anything else in the codebase.</p> <p>“Come on, I just added a simple print statement. Why do I need to wait 30 minutes to merge this code?” - you, probably.</p> <p>Well, pants is here to save you.</p> <h4 id="lets-put-some-pants-on-your-ci-pipeline">Let’s put some pants on your CI pipeline</h4> <p>Beyond what you are hopefully wearing right now at work, pants also refers to a build system. As the <a href="https://www.pantsbuild.org/stable/docs/introduction/welcome-to-pants">docs mention</a>, it wraps many underlying tools - “compilers, code generators, dependency resolvers, test runners, linters, formatters, packagers, REPLs and more.” You can read more about it, but the main thing we’re going to focus on is its dependency inference capabilities and how that affects testing.</p> <p><strong>pants’ dependency inference lets us run only affected tests.</strong> On a very high level, pants knows which files are connected. It automatically scans through your imports and says “Hey, it looks like <code class="language-plaintext highlighter-rouge">test_foo.py</code> depends on <code class="language-plaintext highlighter-rouge">foo.py</code>”.</p> <p>Using information like this, pants can run only the tests that are affected by changes you make in a new branch. The command looks like the following:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pants <span class="nt">--changed-since</span><span class="o">=</span>origin/main <span class="nb">test</span>
</code></pre></div></div> <p>If you make changes to <code class="language-plaintext highlighter-rouge">foo.py</code> it might say: “Hey, I can see that in this new branch, the one file that changed compared to the <code class="language-plaintext highlighter-rouge">main</code> branch is <code class="language-plaintext highlighter-rouge">foo.py</code>. Since <code class="language-plaintext highlighter-rouge">test_foo.py</code> is the one test that depends on this, let’s just run that test.”</p> <p>Now, consider the scenario where <code class="language-plaintext highlighter-rouge">bar.py</code> also depends on <code class="language-plaintext highlighter-rouge">foo.py</code>. It also has its own unit test <code class="language-plaintext highlighter-rouge">test_bar.py</code> that only imports from <code class="language-plaintext highlighter-rouge">bar.py</code>. When you change <code class="language-plaintext highlighter-rouge">foo.py</code> you want to ensure that <code class="language-plaintext highlighter-rouge">bar.py</code> also still works as expected i.e. you want <code class="language-plaintext highlighter-rouge">test_bar.py</code> to also run! <code class="language-plaintext highlighter-rouge">test_bar.py</code> is a <em>transitive</em> dependent. You can run the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pants <span class="nt">--changed-since</span><span class="o">=</span>origin/main <span class="nt">--changed-dependents</span><span class="o">=</span>transitive <span class="nb">test</span>
</code></pre></div></div> <p>Here, pants says “Hey, you changed <code class="language-plaintext highlighter-rouge">foo.py</code>, and I can see that <code class="language-plaintext highlighter-rouge">test_foo.py</code> as well as <code class="language-plaintext highlighter-rouge">test_bar.py</code> depend on <code class="language-plaintext highlighter-rouge">foo.py</code> directly and transitively, respectively. Let me run both unit tests.”</p> <p>The speed up that you can get from this depends on how many tests you have, and how long each one takes. As a toy example, let’s say you have 100 independent modules, each with their own test that takes 1 second to run. In a new feature branch, you only change one of the modules. In this case, testing without pants would take 100 seconds, while testing with pants would take only 1 second.</p> <h4 id="reducing-ci-test-load-by-another-60">Reducing CI test load by another 60%</h4> <p>In our case, we noticed a huge improvement to our testing times after the introduction of pants. Over time, however, I noticed that small changes in certain parts of the codebase were still triggering a whole swarm of tests.</p> <p>The approach outlined in the previous section is only as affective as your software design: for example, if all unit tests depend on a module <code class="language-plaintext highlighter-rouge">Foo</code>, and <code class="language-plaintext highlighter-rouge">Foo</code> depends on all other parts of the codebase, you’re back at square one: any change triggers all unit tests, so you don’t get as much of a speed up as you would ideally have.</p> <p>Thankfully, pants’ <code class="language-plaintext highlighter-rouge">dependents</code> (<a href="https://www.pantsbuild.org/dev/docs/using-pants/project-introspection#dependents---find-which-targets-depend-on-a-target">documentation</a>) and <code class="language-plaintext highlighter-rouge">paths</code> (<a href="https://www.pantsbuild.org/dev/docs/using-pants/project-introspection#paths---find-dependency-paths">documentation</a>) commands are perfect for this scenario.</p> <p>The <code class="language-plaintext highlighter-rouge">dependents</code> command shows you the list of files that depend on the file that you’re inspecting. Since our testing is done with the <code class="language-plaintext highlighter-rouge">--transitive</code> flag, we use the same flag for this command as well.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pants dependents <span class="nt">--transitive</span> &lt;file_name&gt;
</code></pre></div></div> <p>I picked a set of files that I knew were triggering unexpected tests, then filtered the outputs to only include test files.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pants dependents <span class="nt">--transitive</span> &lt;file_name&gt; | <span class="nb">grep </span>tests
</code></pre></div></div> <p>This gave me a set of tests that I could inspect. Given these tests, I used the <code class="language-plaintext highlighter-rouge">paths</code> command to figure out the dependency path:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pants paths <span class="nt">--from</span><span class="o">=</span>&lt;test_file&gt; <span class="nt">--to</span><span class="o">=</span>&lt;file_name&gt;
</code></pre></div></div> <p>In our case we got outputs like the following:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>
  <span class="o">[</span>
    &lt;test_file&gt;,
    ...,
    /.../conftest.py,
    ...,
    &lt;file_name&gt;,
  <span class="o">]</span>
<span class="o">]</span>
</code></pre></div></div> <p>Aha! A <code class="language-plaintext highlighter-rouge">conftest.py</code> was importing a whole range of dependencies, and since all tests in the suite depend on <code class="language-plaintext highlighter-rouge">conftest.py</code> although they don’t explicitly import from this file, <code class="language-plaintext highlighter-rouge">pants</code> was triggering a whole bunch of unrelated tests!</p> <p>To solve this, I refactored our test modules to break apart this dependency. I figured out what fixtures from the <code class="language-plaintext highlighter-rouge">conftest.py</code> were needed in which tests, and put them in their respective tests. Interestingly enough, it was very rare for a fixture in <code class="language-plaintext highlighter-rouge">confest.py</code> to actually be needed across multiple tests.</p> <p><strong>This fix reduced the average number of tests a given file triggers by 60%</strong>, a substantial improvement for us!</p> <h4 id="conclusion">Conclusion</h4> <p>I’ve thoroughly enjoyed using pants as it allows us to do what is only necessary. We also use it for linting, formatting, and type checking only the files that are affected by any changes since the main branch.</p> <p>I think the commands that I’ve found the most useful for me are <code class="language-plaintext highlighter-rouge">dependents</code> and <code class="language-plaintext highlighter-rouge">dependencies</code>, as they can help you to understand the structure of your code a lot better, and possibly fix things if the structure doesn’t meet your expectations e.g. “this module shouldn’t depend on this!”</p> <p>You can read more about some of the history of pants <a href="https://earthly.dev/blog/pants-build/">here</a>, and how to use it from the documentation <a href="https://www.pantsbuild.org/stable/docs/introduction/welcome-to-pants">here</a>.</p>]]></content><author><name></name></author><category term="software-engineering"/><category term="pants"/><summary type="html"><![CDATA[TL;DR:]]></summary></entry><entry><title type="html">No more SQL: using ibis as a machine learning researcher</title><link href="https://tkbadamdorj.github.io/blog/2025/ibis/" rel="alternate" type="text/html" title="No more SQL: using ibis as a machine learning researcher"/><published>2025-01-20T15:09:00+00:00</published><updated>2025-01-20T15:09:00+00:00</updated><id>https://tkbadamdorj.github.io/blog/2025/ibis</id><content type="html" xml:base="https://tkbadamdorj.github.io/blog/2025/ibis/"><![CDATA[<h1 id="tldr">TL;DR:</h1> <ul> <li>I am afraid of SQL</li> <li><a href="https://pandas.pydata.org/"><code class="language-plaintext highlighter-rouge">pandas</code></a> <em>was</em> great until it wasn’t <ul> <li>it doesn’t do so well with large scale data</li> </ul> </li> <li><a href="https://duckdb.org/">duckdb</a> gives you a powerful backend for dealing with larger scale data, but you need to know SQL</li> <li><a href="https://ibis-project.org/"><code class="language-plaintext highlighter-rouge">ibis</code></a> lets you use pythonic, pandas-like syntax while letting you use duckdb as a backend <ul> <li>in total they have 20+ backends (also including polars and other SQL backends)</li> <li>using <code class="language-plaintext highlighter-rouge">ibis</code> lets you write and execute complicated SQL queries in a pythonic way</li> </ul> </li> </ul> <hr/> <h3 id="ml-researchers-have-low-self-esteem-because-they-cant-write-sql">ML researchers have low self-esteem because they can’t write SQL</h3> <p>The machine learning researcher pipeline goes: you get really good grades in university, go to grad school, work on common benchmark datasets with a huge focus improving the state-of-the-art by developing new algorithms.</p> <p>If you’re really bold, you collect and annotate your own dataset.</p> <p>Then you go to a company and you feel bad.</p> <p>“What? I have to access this table where? How do I query it? How do I transform it to get it into the format I want? How can I explore this? It doesn’t fit into memory as a lovely <code class="language-plaintext highlighter-rouge">DataFrame</code> that I can manipulate how I want to.”</p> <p>You’re stuck. You used to be a somebody.</p> <p>“If only… if only someone smarter than me wrote a tool that has a simple pythonic, pandas-like API that lets me do all the cool stuff the data engineers do,” you think to yourself.</p> <p>You look up. The data engineers are doing kickflips outside.</p> <h3 id="why-isnt-pandas-sufficient">Why isn’t <code class="language-plaintext highlighter-rouge">pandas</code> sufficient?</h3> <p><code class="language-plaintext highlighter-rouge">pandas</code> is the de-facto library that researchers have come to love and use. With its trove of useful functions and simple python syntax, it’s great when you’re not dealing with large scale data.</p> <p>As Wes McKinney, the creator of pandas says in “10 Things I Hate About Pandas” (<a href="https://wesmckinney.com/blog/apache-arrow-pandas-internals/">link</a>), his rule of thumb for pandas is that you should have <strong>5 to 10 times as much RAM</strong> as the size of your dataset. When you’re dealing with terabytes of data, this is impossible to achieve.</p> <p>In summary:</p> <ul> <li>ease of use ✅</li> <li>processing large scale data ❌</li> </ul> <h3 id="i-heard-a-quack-enter-duckdb">I heard a quack: enter <code class="language-plaintext highlighter-rouge">duckdb</code></h3> <p><a href="https://duckdb.org/">duckdb</a> on the other hand is an open source database system. You can query and transform your data anywhere, and as the website says, you can process larger-than-memory workloads! It’s a much better alternative to pandas in terms of dealing with large scale data, but you need to know SQL. For example, to get the average bill length and maximum flipper length for each group of birds (by species and island), the SQL query looks like the following:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># get average bill length and maximum flipper length
</span><span class="kn">import</span> <span class="n">duckdb</span>
<span class="n">duckdb</span><span class="p">.</span><span class="nf">sql</span><span class="p">(</span><span class="sh">"""</span><span class="s">
	SELECT 
	    species, 
	    island, 
	    AVG(bill_length_mm) AS </span><span class="sh">"</span><span class="s">Mean(bill_length_mm)</span><span class="sh">"</span><span class="s">, 
	    MAX(flipper_length_mm) AS </span><span class="sh">"</span><span class="s">Max(flipper_length_mm)</span><span class="sh">"</span><span class="s">
	FROM penguins
	GROUP BY species, island
    </span><span class="sh">"""</span><span class="p">)</span>
</code></pre></div></div> <p>Writing SQL inside of a python string is ok, but maybe not the prettiest.</p> <p>In summary:</p> <ul> <li>ease of use ❌ (if you don’t know SQL)</li> <li>processing large scale data ✅</li> </ul> <h3 id="the-ibis-has-landed">The <code class="language-plaintext highlighter-rouge">ibis</code> has landed</h3> <p>Thankfully, there’s a third alternative that combines ease of use with the ability to process large scale data.</p> <p><a href="https://ibis-project.org/why">ibis</a> is a python package that acts as an interface between you and the query engine. ibis supports over 20 query engines including duckdb. On top of that they support polars, BiqQuery, ClickHouse, MySQL, PostgreSQL, and a variety of others!</p> <p>The whole philosophy behind ibis is to create a common user interface for all the different query engines. You can change what query engine to use without changing any of your ibis code.</p> <p>With <code class="language-plaintext highlighter-rouge">ibis</code>, we can rewrite the example above in a much more pythonic way:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">ibis</span>
<span class="p">(</span>
    <span class="n">penguins</span>
    <span class="p">.</span><span class="nf">group_by</span><span class="p">([</span><span class="n">penguins</span><span class="p">.</span><span class="n">species</span><span class="p">,</span> <span class="n">penguins</span><span class="p">.</span><span class="n">island</span><span class="p">])</span>
    <span class="p">.</span><span class="nf">aggregate</span><span class="p">(</span>
	<span class="p">[</span>
	    <span class="n">penguins</span><span class="p">.</span><span class="n">bill_length_mm</span><span class="p">.</span><span class="nf">mean</span><span class="p">(),</span> 
	    <span class="n">penguins</span><span class="p">.</span><span class="n">flipper_length_mm</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span>
	<span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div> <p>I found the syntax much more friendly compared to duckdb. Since the backend uses duckdb, we also don’t lose out on any performance benefits by using ibis.</p> <p>ibis thus meets the two things we were looking for:</p> <ul> <li>ease of use ✅</li> <li>processing large scale data ✅</li> </ul> <p>Another benefit of ibis is that since it is query engine-agnostic, if one of the query engines develops a new feature that is way faster than the others, you don’t have to rewrite your ibis code! You can just change the backend.</p> <h3 id="you-can-pretend-to-be-a-cool-data-engineer-now">You can pretend to be a cool data engineer now</h3> <p>Now that you know about <code class="language-plaintext highlighter-rouge">ibis</code> you can do some of the things that the cool skateboarding data engineers can do. You won’t be able to do all the cool things they can do, but hey at least you won’t embarrass yourself any further.</p> <p>Give ibis a try! I found the <code class="language-plaintext highlighter-rouge">ibis</code> tutorials <a href="https://ibis-project.org/tutorials/getting_started#group_by">here</a> very useful.</p>]]></content><author><name></name></author><category term="data-engineering"/><summary type="html"><![CDATA[How to give in to your fears of SQL and/or possibly improve your life]]></summary></entry></feed>